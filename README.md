# Algorithm Efficiency Mini Project  
### *By: Your Name*

This project analyses the **execution time and behavior of fundamental algorithms** taught in Data Structures & Algorithms.  
All experiments are performed using **Python in Google Colab**, and results include **graphs, observations, and comparisons**.

---

## ğŸ“Œ **Algorithms Analyzed**
1. **Fibonacci (Recursive)**
2. **Fibonacci (Dynamic Programming)**
3. **Merge Sort**
4. **Quick Sort**
5. **Insertion Sort**
6. **Bubble Sort**
7. **Selection Sort**
8. **Binary Search**

---

## ğŸ“˜ **Objective**
To study:
- Execution time with different input sizes  
- Differences between recursive, iterative, and divide-and-conquer algorithms  
- Best, average, worst-case complexity  
- Practical performance compared to theoretical Big-O

---

## ğŸ› ï¸ **Technologies Used**
- Python  
- Google Colab  
- Matplotlib  
- Random module  
- Time module  

---

## ğŸ“Š **Project Structure**
```
algorithm_efficiency_project/
â”‚
â”œâ”€â”€ algorithm_analysis.ipynb     # Main notebook with code, plots, summary
â”œâ”€â”€ images/                      # Folder containing all generated graphs
â”‚     â”œâ”€â”€ merge_sort.png
â”‚     â”œâ”€â”€ quick_sort.png
â”‚     â”œâ”€â”€ fibonacci_recursive.png
â”‚     â”œâ”€â”€ fibonacci_dp.png
â”‚     â””â”€â”€ ...
â””â”€â”€ README.md
```

---

## ğŸ“ˆ **Experiments Performed**

### âœ” Sorting Algorithms  
Tested with input sizes:  
`[100, 300, 500, 1000, 2000, 5000]`

Generated graphs:
- Time vs Input Size for each sorting algorithm

### âœ” Fibonacci  
- Recursive tested for small input only (due to exponential time)  
- DP tested for large input sizes up to 50,000  

### âœ” Binary Search  
Tested with sorted arrays from size:  
`1000 â†’ 100,000`

---

## ğŸ§  **Key Observations**
- **Merge Sort** and **Quick Sort** perform much faster than other O(nÂ²) sorting algorithms.
- **Insertion Sort** is fast only for small or nearly-sorted arrays.
- **Recursive Fibonacci** is extremely slow for large inputs (exponential).
- **Fibonacci DP** is extremely fast, even for large inputs.
- **Binary Search** shows almost constant time due to logarithmic complexity.

---

## ğŸ“š **Time Complexities**

| Algorithm | Best | Average | Worst |
|----------|------|----------|--------|
| Fibonacci (Recursive) | â€” | â€” | O(2â¿) |
| Fibonacci (DP) | O(n) | O(n) | O(n) |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) |
| Quick Sort | O(n log n) | O(n log n) | O(nÂ²) |
| Insertion Sort | O(n) | O(nÂ²) | O(nÂ²) |
| Bubble Sort | O(n) | O(nÂ²) | O(nÂ²) |
| Selection Sort | O(nÂ²) | O(nÂ²) | O(nÂ²) |
| Binary Search | O(1) | O(log n) | O(log n) |

---

## ğŸš€ **How to Run the Project**

1. Open **Google Colab**
2. Upload the notebook `algorithm_analysis.ipynb`
3. Run all cells in order:
   - Imports  
   - Algorithm definitions  
   - Experiment code  
   - Graph plotting  
4. All graphs will automatically appear  
5. Download them into the `images/` folder for GitHub

---

## ğŸ“¥ **Installation (Optional â€“ For Local Use)**

```
pip install numpy matplotlib
```

---

## ğŸ“ **Notes**
- This project is created strictly for academic learning.
- All graphs and results are generated by running Python experiments.
- The notebook follows the mini-project instructions provided by the faculty.

---

## ğŸ“Œ **Conclusion**
This project successfully demonstrates how different algorithms behave with varying input sizes.  
It highlights the importance of:
- Algorithm choice  
- Complexity analysis  
- Real-world performance testing  

The results match theoretical expectations and provide a clear understanding of algorithm efficiency.

---

